import { supabase, handleSupabaseError, handleSupabaseSuccess } from '../lib/supabase';
import {
  User,
  Client,
  Device,
  Service,
  Part,
  Product,
  Repair,
  Message,
  Appointment,
  Sale,
  StockAlert,
  Notification,
  DashboardStats
} from '../types';

// Service pour les param√®tres syst√®me
export const systemSettingsService = {
  async getAll() {
    console.log('üîç systemSettingsService.getAll() appel√©');
    try {
      // R√©cup√©rer l'utilisateur actuel
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        console.log('‚ùå Aucun utilisateur connect√©');
        return handleSupabaseSuccess([]);
      }

      const { data, error } = await supabase
        .from('system_settings')
        .select('*')
        .eq('user_id', user.id)
        .order('category', { ascending: true })
        .order('key', { ascending: true });
      
      console.log('üìä R√©sultat Supabase:', { data, error });
      
      if (error) {
        console.error('‚ùå Erreur Supabase:', error);
        return handleSupabaseError(error);
      }
      
      console.log('‚úÖ Donn√©es r√©cup√©r√©es:', data);
      return handleSupabaseSuccess(data || []);
    } catch (err) {
      console.error('üí• Exception dans getAll:', err);
      return handleSupabaseSuccess([]);
    }
  },

  async getByCategory(category: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseSuccess([]);
      }

      const { data, error } = await supabase
        .from('system_settings')
        .select('*')
        .eq('user_id', user.id)
        .eq('category', category)
        .order('key', { ascending: true });
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data || []);
    } catch (err) {
      return handleSupabaseSuccess([]);
    }
  },

  async getByKey(key: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { data, error } = await supabase
        .from('system_settings')
        .select('*')
        .eq('user_id', user.id)
        .eq('key', key)
        .single();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async update(key: string, value: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { data, error } = await supabase
        .from('system_settings')
        .update({ value, updated_at: new Date().toISOString() })
        .eq('user_id', user.id)
        .eq('key', key)
        .select()
        .single();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async updateMultiple(settings: Array<{ key: string; value: string }>) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const updates = settings.map(setting => ({
        user_id: user.id,
        key: setting.key,
        value: setting.value,
        updated_at: new Date().toISOString()
      }));

      const { data, error } = await supabase
        .from('system_settings')
        .upsert(updates, { onConflict: 'user_id,key' })
        .select();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data || []);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async create(setting: { key: string; value: string; description?: string; category?: string }) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { data, error } = await supabase
        .from('system_settings')
        .insert([{
          user_id: user.id,
          key: setting.key,
          value: setting.value,
          description: setting.description,
          category: setting.category || 'general'
        }])
        .select()
        .single();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async delete(key: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { error } = await supabase
        .from('system_settings')
        .delete()
        .eq('user_id', user.id)
        .eq('key', key);
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(true);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  }
};

// Service pour les utilisateurs
export const userService = {
  async getCurrentUser() {
    try {
      // D'abord essayer de r√©cup√©rer l'utilisateur depuis Supabase Auth
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      
      if (authError || !user) {
        console.log('‚ö†Ô∏è Aucun utilisateur authentifi√© via Supabase Auth');
        return handleSupabaseSuccess(null);
      }
      
      // Ensuite r√©cup√©rer les d√©tails complets depuis notre table users
      const { data: userData, error: userError } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .single();
      
      if (userError) {
        console.log('‚ö†Ô∏è Utilisateur non trouv√© dans la table users, utilisation des donn√©es auth');
        return handleSupabaseSuccess(user);
      }
      
      // Convertir les donn√©es de snake_case vers camelCase
      const convertedUser = {
        id: userData.id,
        firstName: userData.first_name || userData.firstName,
        lastName: userData.last_name || userData.lastName,
        email: userData.email,
        role: userData.role || 'technician',
        avatar: userData.avatar,
        createdAt: userData.created_at ? new Date(userData.created_at) : new Date(),
        updatedAt: userData.updated_at ? new Date(userData.updated_at) : new Date()
      };
      
      return handleSupabaseSuccess(convertedUser);
    } catch (err) {
      console.error('‚ùå Erreur dans getCurrentUser:', err);
      return handleSupabaseError(err as any);
    }
  },

  async getAllUsers() {
    console.log('üîç getAllUsers() appel√©');
    
    try {
      // Utiliser la fonction RPC pour r√©cup√©rer seulement les utilisateurs cr√©√©s par l'utilisateur actuel
      let { data, error } = await supabase.rpc('get_my_users');
      
      if (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des utilisateurs:', error);
        
        // Fallback vers la r√©cup√©ration normale si la fonction RPC n'existe pas
        console.log('‚ö†Ô∏è Fonction RPC non disponible, utilisation de la r√©cup√©ration normale...');
        const { data: fallbackData, error: fallbackError } = await supabase
          .from('users')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (fallbackError) {
          console.error('‚ùå Erreur lors de la r√©cup√©ration de fallback:', fallbackError);
          return handleSupabaseError(fallbackError);
        }
        
        data = fallbackData;
      }
      
      console.log('üìä Donn√©es brutes r√©cup√©r√©es:', data);
      
      // Convertir les donn√©es de snake_case vers camelCase
      const convertedData = data?.map((user: any) => ({
        id: user.id,
        firstName: user.first_name || user.firstName,
        lastName: user.last_name || user.lastName,
        email: user.email,
        role: user.role || 'technician',
        avatar: user.avatar,
        createdAt: user.created_at ? new Date(user.created_at) : new Date(),
        updatedAt: user.updated_at ? new Date(user.updated_at) : new Date()
      })) || [];
      
      console.log('‚úÖ Utilisateurs convertis:', convertedData);
      return handleSupabaseSuccess(convertedData);
    } catch (err) {
      console.error('‚ùå Erreur inattendue dans getAllUsers:', err);
      return handleSupabaseError(err as any);
    }
  },

  async createUser(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'> & { password: string }) {
    try {
      console.log('üîß Cr√©ation d\'utilisateur:', userData);
      
      // V√©rifier si l'email existe d√©j√† (approche plus robuste)
      const { data: existingUsers, error: checkError } = await supabase
        .from('users')
        .select('id, email')
        .eq('email', userData.email);

      if (checkError) {
        console.error('‚ùå Erreur lors de la v√©rification de l\'email:', checkError);
        return handleSupabaseError(checkError);
      }

      if (existingUsers && existingUsers.length > 0) {
        console.error('‚ùå Email d√©j√† utilis√©:', userData.email);
        return handleSupabaseError({
          message: `L'email "${userData.email}" est d√©j√† utilis√© par un autre utilisateur.`,
          code: 'EMAIL_EXISTS'
        });
      }
      
      // Essayer d'abord la fonction RPC principale
      let rpcData, rpcError;
      
      try {
        const result = await supabase.rpc('create_user_with_email_check', {
          p_user_id: crypto.randomUUID(),
          p_first_name: userData.firstName,
          p_last_name: userData.lastName,
          p_email: userData.email,
          p_role: userData.role,
          p_avatar: userData.avatar
        });
        rpcData = result.data;
        rpcError = result.error;
      } catch (err) {
        console.log('‚ö†Ô∏è Fonction RPC principale non disponible, essai avec fallback...');
        rpcError = err;
      }

      // Si la fonction principale √©choue, essayer la fonction de fallback
      if (rpcError) {
        try {
          const fallbackResult = await supabase.rpc('create_user_simple_fallback', {
            p_user_id: crypto.randomUUID(),
            p_first_name: userData.firstName,
            p_last_name: userData.lastName,
            p_email: userData.email,
            p_role: userData.role,
            p_avatar: userData.avatar
          });
          rpcData = fallbackResult.data;
          rpcError = fallbackResult.error;
        } catch (fallbackErr) {
          console.error('‚ùå Erreur lors de l\'appel RPC de fallback:', fallbackErr);
          rpcError = fallbackErr;
        }
      }

      if (rpcError) {
        console.error('‚ùå Erreur lors de l\'appel RPC:', rpcError);
        return handleSupabaseError(rpcError);
      }

      if (!rpcData || !rpcData.success) {
        console.error('‚ùå Erreur lors de la cr√©ation:', rpcData?.error);
        return handleSupabaseError({ 
          message: rpcData?.error || 'Erreur lors de la cr√©ation de l\'utilisateur',
          code: 'RPC_ERROR'
        });
      }

      console.log('‚úÖ Utilisateur cr√©√© avec succ√®s:', rpcData.data);
      return handleSupabaseSuccess(rpcData.data);
    } catch (err) {
      console.error('üí• Exception lors de la cr√©ation:', err);
      return handleSupabaseError(err as any);
    }
  },

  async updateUser(id: string, updates: Partial<User>) {
    try {
      console.log('üîß Mise √† jour d\'utilisateur:', { id, updates });
      
      // Mettre √† jour l'enregistrement dans la table users
      const updateData: any = {
        updated_at: new Date().toISOString()
      };

      if (updates.firstName) updateData.first_name = updates.firstName;
      if (updates.lastName) updateData.last_name = updates.lastName;
      if (updates.role) updateData.role = updates.role;
      if (updates.avatar) updateData.avatar = updates.avatar;

      console.log('üìù Donn√©es de mise √† jour:', updateData);

      const { data, error } = await supabase
        .from('users')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur lors de la mise √† jour:', error);
        return handleSupabaseError(error);
      }
      
      console.log('‚úÖ Utilisateur mis √† jour avec succ√®s:', data);
      return handleSupabaseSuccess(data);
    } catch (err) {
      console.error('üí• Exception lors de la mise √† jour:', err);
      return handleSupabaseError(err as any);
    }
  },

  async deleteUser(id: string) {
    try {
      console.log('üîß Suppression d\'utilisateur:', id);
      
      // Supprimer l'enregistrement de la table users
      const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('‚ùå Erreur lors de la suppression:', error);
        return handleSupabaseError(error);
      }
      
      console.log('‚úÖ Utilisateur supprim√© avec succ√®s');
      return handleSupabaseSuccess(true);
    } catch (err) {
      console.error('üí• Exception lors de la suppression:', err);
      return handleSupabaseError(err as any);
    }
  },

  async signIn(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async signUp(email: string, password: string, userData: Partial<User>) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: userData,
        emailRedirectTo: `${window.location.origin}/auth?tab=confirm`
      }
    });
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async signOut() {
    const { error } = await supabase.auth.signOut();
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Fonction utilitaire pour r√©cup√©rer l'utilisateur connect√© avec son r√¥le
async function getCurrentUser(): Promise<{ id: string; role: string } | null> {
  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error || !user) {
      console.log('‚ö†Ô∏è Aucun utilisateur authentifi√©');
      return null;
    }
    
    // R√©cup√©rer tous les utilisateurs et filtrer c√¥t√© client pour √©viter les erreurs 406
    const { data: allUsers, error: userError } = await supabase
      .from('users')
      .select('*');
    
    if (userError) {
      console.log('‚ö†Ô∏è Erreur lors de la r√©cup√©ration des utilisateurs:', userError);
      return null;
    }
    
    // Chercher l'utilisateur connect√© dans la liste
    const currentUser = allUsers?.find(u => u.id === user.id);
    
    if (!currentUser) {
      console.log('‚ö†Ô∏è Utilisateur non trouv√© dans la table users:', user.id);
      
      // Tentative de cr√©ation automatique de l'utilisateur via fonction RPC
      try {
        console.log('üîÑ Tentative de cr√©ation automatique de l\'utilisateur via fonction RPC...');
        
        // Essayer diff√©rents r√¥les dans l'ordre de priorit√©
        const rolesToTry = ['technician', 'manager', 'admin', 'user'];
        let newUser = null;
        let insertError = null;
        
        for (const role of rolesToTry) {
          try {
            const { data, error } = await supabase.rpc('create_user_automatically', {
              user_id: user.id,
              first_name: user.user_metadata?.first_name || 'Utilisateur',
              last_name: user.user_metadata?.last_name || 'Test',
              user_email: user.email,
              user_role: role
            });
            
            if (!error && data && data.success) {
              newUser = data.user;
              console.log('‚úÖ Utilisateur cr√©√© automatiquement avec le r√¥le:', role);
              break;
            } else {
              console.log(`‚ö†Ô∏è R√¥le '${role}' non autoris√©, essai suivant...`);
              insertError = error || data?.error;
            }
          } catch (err) {
            console.log(`‚ö†Ô∏è Erreur avec le r√¥le '${role}':`, err);
            insertError = err;
          }
        }
        
        if (!newUser) {
          console.error('‚ùå Aucun r√¥le autoris√© trouv√© pour la cr√©ation automatique:', insertError);
          return null;
        }
        
        console.log('‚úÖ Utilisateur cr√©√© automatiquement dans la table users:', newUser.id, 'R√¥le:', newUser.role);
        return { id: newUser.id, role: newUser.role };
      } catch (createErr) {
        console.error('‚ùå Erreur lors de la cr√©ation automatique:', createErr);
        return null;
      }
    }
    
    console.log('‚úÖ Utilisateur trouv√© dans la table users:', currentUser.id, 'R√¥le:', currentUser.role);
    return { id: currentUser.id, role: currentUser.role };
  } catch (err) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration de l\'utilisateur:', err);
    return null;
  }
}

// Fonction utilitaire pour r√©cup√©rer l'utilisateur connect√© (compatibilit√©)
async function getCurrentUserId(): Promise<string | null> {
  const user = await getCurrentUser();
  return user?.id || null;
}

// Service pour les clients
export const clientService = {
  async getAll() {
    // Utiliser directement l'authentification Supabase pour l'isolation
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError || !user) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, retourner une liste vide');
      return handleSupabaseSuccess([]);
    }
    
    console.log('üîí R√©cup√©ration des clients pour l\'utilisateur:', user.id);
    
    // La politique RLS va automatiquement filtrer les donn√©es
    const { data, error } = await supabase
      .from('clients')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data?.map(client => ({
      id: client.id,
      firstName: client.first_name,
      lastName: client.last_name,
      email: client.email,
      phone: client.phone,
      address: client.address,
      notes: client.notes,
      createdAt: client.created_at,
      updatedAt: client.updated_at
    })) || [];
    
    console.log('‚úÖ Clients r√©cup√©r√©s:', convertedData.length, 'pour l\'utilisateur:', user.id);
    return handleSupabaseSuccess(convertedData);
  },

  async getById(id: string) {
    // R√©cup√©rer l'utilisateur connect√©
    const currentUserId = await getCurrentUserId();
    
    if (!currentUserId) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, r√©cup√©ration du client sans filtrage');
      const { data, error } = await supabase
        .from('clients')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data);
    }
    
    // R√©cup√©rer le client de l'utilisateur connect√©
    const { data, error } = await supabase
      .from('clients')
      .select('*')
      .eq('id', id)
      .eq('user_id', currentUserId)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(client: Omit<Client, 'id' | 'createdAt' | 'updatedAt'>) {
    // R√©cup√©rer l'utilisateur connect√©
    const currentUserId = await getCurrentUserId();
    
    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const clientData = {
      first_name: client.firstName,
      last_name: client.lastName,
      email: client.email,
      phone: client.phone,
      address: client.address,
      notes: client.notes,
      user_id: currentUserId || '00000000-0000-0000-0000-000000000000', // Utiliser l'utilisateur syst√®me par d√©faut si non connect√©
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('clients')
      .insert([clientData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Client>) {
    // R√©cup√©rer l'utilisateur connect√©
    const currentUserId = await getCurrentUserId();
    
    if (!currentUserId) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, mise √† jour sans filtrage');
      const { data, error } = await supabase
        .from('clients')
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single();
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(data);
    }
    
    // Mettre √† jour le client de l'utilisateur connect√©
    const { data, error } = await supabase
      .from('clients')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', currentUserId)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // R√©cup√©rer l'utilisateur connect√©
    const currentUserId = await getCurrentUserId();
    
    if (!currentUserId) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, suppression sans filtrage');
      const { error } = await supabase
        .from('clients')
        .delete()
        .eq('id', id);
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess(true);
    }
    
    // Supprimer le client de l'utilisateur connect√©
    const { error } = await supabase
      .from('clients')
      .delete()
      .eq('id', id)
      .eq('user_id', currentUserId);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les appareils
export const deviceService = {
  async getAll() {
    // Utiliser directement l'authentification Supabase pour l'isolation
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError || !user) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, retourner une liste vide');
      return handleSupabaseSuccess([]);
    }
    
    console.log('üîí R√©cup√©ration des appareils pour l\'utilisateur:', user.id);
    
    // La politique RLS va automatiquement filtrer les donn√©es
    const { data, error } = await supabase
      .from('devices')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data?.map(device => ({
      id: device.id,
      brand: device.brand,
      model: device.model,
      serialNumber: device.serial_number,
      type: device.type,
      specifications: device.specifications,
      createdAt: device.created_at,
      updatedAt: device.updated_at
    })) || [];
    
    console.log('‚úÖ Appareils r√©cup√©r√©s:', convertedData.length, 'pour l\'utilisateur:', user.id);
    return handleSupabaseSuccess(convertedData);
  },

  async getById(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('devices')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(device: Omit<Device, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const deviceData = {
      brand: device.brand,
      model: device.model,
      serial_number: device.serialNumber,
      type: device.type,
      specifications: device.specifications,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('devices')
      .insert([deviceData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Device>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('devices')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { error } = await supabase
      .from('devices')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les r√©parations
export const repairService = {
  async getAll() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('repairs')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data?.map(repair => ({
      id: repair.id,
      clientId: repair.client_id,
      deviceId: repair.device_id,
      status: repair.status,
      assignedTechnicianId: repair.assigned_technician_id,
      description: repair.description,
      issue: repair.issue,
      estimatedDuration: repair.estimated_duration,
      actualDuration: repair.actual_duration,
      estimatedStartDate: repair.estimated_start_date,
      estimatedEndDate: repair.estimated_end_date,
      startDate: repair.start_date,
      endDate: repair.end_date,
      dueDate: repair.due_date,
      isUrgent: repair.is_urgent,
      notes: repair.notes,
      services: [], // Tableau vide par d√©faut
      parts: [], // Tableau vide par d√©faut
      totalPrice: repair.total_price,
      isPaid: repair.is_paid,
      createdAt: repair.created_at,
      updatedAt: repair.updated_at
    })) || [];
    
    return handleSupabaseSuccess(convertedData);
  },

  async getById(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('repairs')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(repair: Omit<Repair, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // V√©rifier que le client appartient √† l'utilisateur connect√© ou est un client syst√®me
    if (repair.clientId) {
      const { data: clientData, error: clientError } = await supabase
        .from('clients')
        .select('id')
        .eq('id', repair.clientId)
        .or(`user_id.eq.${user.id},user_id.eq.00000000-0000-0000-0000-000000000000`)
        .single();
      
      if (clientError || !clientData) {
        return handleSupabaseError(new Error('Client non trouv√© ou n\'appartient pas √† l\'utilisateur connect√©'));
      }
    }

    // V√©rifier que le device appartient √† l'utilisateur connect√© ou est un device syst√®me
    if (repair.deviceId) {
      const { data: deviceData, error: deviceError } = await supabase
        .from('devices')
        .select('id')
        .eq('id', repair.deviceId)
        .or(`user_id.eq.${user.id},user_id.eq.00000000-0000-0000-0000-000000000000`)
        .single();
      
      if (deviceError || !deviceData) {
        return handleSupabaseError(new Error('Appareil non trouv√© ou n\'appartient pas √† l\'utilisateur connect√©'));
      }
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const repairData = {
      client_id: repair.clientId,
      device_id: repair.deviceId,
      status: repair.status,
      assigned_technician_id: repair.assignedTechnicianId,
      description: repair.description,
      issue: repair.issue,
      estimated_duration: repair.estimatedDuration,
      actual_duration: repair.actualDuration,
      estimated_start_date: repair.estimatedStartDate,
      estimated_end_date: repair.estimatedEndDate,
      start_date: repair.startDate,
      end_date: repair.endDate,
      due_date: repair.dueDate,
      is_urgent: repair.isUrgent,
      notes: repair.notes,
      total_price: repair.totalPrice,
      is_paid: repair.isPaid,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('repairs')
      .insert([repairData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Repair>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const updateData: any = { updated_at: new Date().toISOString() };
    
    if (updates.clientId !== undefined) updateData.client_id = updates.clientId;
    if (updates.deviceId !== undefined) updateData.device_id = updates.deviceId;
    if (updates.status !== undefined) updateData.status = updates.status;
    if (updates.assignedTechnicianId !== undefined) updateData.assigned_technician_id = updates.assignedTechnicianId;
    if (updates.description !== undefined) updateData.description = updates.description;
    if (updates.issue !== undefined) updateData.issue = updates.issue;
    if (updates.estimatedDuration !== undefined) updateData.estimated_duration = updates.estimatedDuration;
    if (updates.actualDuration !== undefined) updateData.actual_duration = updates.actualDuration;
    if (updates.estimatedStartDate !== undefined) updateData.estimated_start_date = updates.estimatedStartDate;
    if (updates.estimatedEndDate !== undefined) updateData.estimated_end_date = updates.estimatedEndDate;
    if (updates.startDate !== undefined) updateData.start_date = updates.startDate;
    if (updates.endDate !== undefined) updateData.end_date = updates.endDate;
    if (updates.dueDate !== undefined) updateData.due_date = updates.dueDate;
    if (updates.isUrgent !== undefined) updateData.is_urgent = updates.isUrgent;
    if (updates.notes !== undefined) updateData.notes = updates.notes;
    if (updates.totalPrice !== undefined) updateData.total_price = updates.totalPrice;
    if (updates.isPaid !== undefined) updateData.is_paid = updates.isPaid;

    const { data, error } = await supabase
      .from('repairs')
      .update(updateData)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { error } = await supabase
      .from('repairs')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  },

  async getByStatus(status: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('repairs')
      .select('*')
      .eq('status', status)
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  }
};

// Service pour les pi√®ces
export const partService = {
  async getAll() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('parts')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async getById(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('parts')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(part: Omit<Part, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const partData = {
      name: part.name,
      description: part.description,
      part_number: part.partNumber,
      brand: part.brand,
      compatible_devices: part.compatibleDevices,
      stock_quantity: part.stockQuantity,
      min_stock_level: part.minStockLevel,
      price: part.price,
      supplier: part.supplier,
      is_active: part.isActive,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('parts')
      .insert([partData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Part>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de colonnes de camelCase vers snake_case
    const dbUpdates: any = { updated_at: new Date().toISOString() };
    
    if (updates.name !== undefined) dbUpdates.name = updates.name;
    if (updates.description !== undefined) dbUpdates.description = updates.description;
    if (updates.partNumber !== undefined) dbUpdates.part_number = updates.partNumber;
    if (updates.brand !== undefined) dbUpdates.brand = updates.brand;
    if (updates.compatibleDevices !== undefined) dbUpdates.compatible_devices = updates.compatibleDevices;
    if (updates.stockQuantity !== undefined) dbUpdates.stock_quantity = updates.stockQuantity;
    if (updates.minStockLevel !== undefined) dbUpdates.min_stock_level = updates.minStockLevel;
    if (updates.price !== undefined) dbUpdates.price = updates.price;
    if (updates.supplier !== undefined) dbUpdates.supplier = updates.supplier;
    if (updates.isActive !== undefined) dbUpdates.is_active = updates.isActive;

    const { data, error } = await supabase
      .from('parts')
      .update(dbUpdates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { error } = await supabase
      .from('parts')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  },

  async getLowStock() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('parts')
      .select('*')
      .eq('user_id', user.id)
      .lte('stock_quantity', 5)
      .order('stock_quantity', { ascending: true });
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  }
};

// Service pour les produits
export const productService = {
  async getAll() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('products')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async getById(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('products')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(product: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const productData = {
      name: product.name,
      description: product.description,
      category: product.category,
      price: product.price,
      stock_quantity: product.stockQuantity,
      is_active: product.isActive,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('products')
      .insert([productData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Product>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de colonnes de camelCase vers snake_case
    const dbUpdates: any = { updated_at: new Date().toISOString() };
    
    if (updates.name !== undefined) dbUpdates.name = updates.name;
    if (updates.description !== undefined) dbUpdates.description = updates.description;
    if (updates.category !== undefined) dbUpdates.category = updates.category;
    if (updates.price !== undefined) dbUpdates.price = updates.price;
    if (updates.stockQuantity !== undefined) dbUpdates.stock_quantity = updates.stockQuantity;
    if (updates.isActive !== undefined) dbUpdates.is_active = updates.isActive;

    const { data, error } = await supabase
      .from('products')
      .update(dbUpdates)
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les ventes
export const saleService = {
  async getAll() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('sales')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data?.map(sale => ({
      id: sale.id,
      clientId: sale.client_id,
      items: sale.items || [],
      subtotal: sale.subtotal,
      tax: sale.tax,
      total: sale.total,
      paymentMethod: sale.payment_method,
      status: sale.status,
      createdAt: sale.created_at,
      updatedAt: sale.updated_at
    })) || [];
    
    return handleSupabaseSuccess(convertedData);
  },

  async getById(id: string) {
    const { data, error } = await supabase
      .from('sales')
      .select(`
        *,
        client:clients(*),
        product:products(*)
      `)
      .eq('id', id)
      .single();
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data ? {
      id: data.id,
      clientId: data.client_id,
      items: data.items || [],
      subtotal: data.subtotal,
      tax: data.tax,
      total: data.total,
      paymentMethod: data.payment_method,
      status: data.status,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
      client: data.client,
      product: data.product
    } : null;
    
    return handleSupabaseSuccess(convertedData);
  },

  async create(sale: Omit<Sale, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // V√©rifier que le client appartient √† l'utilisateur connect√©
    if (sale.clientId) {
      const { data: clientData, error: clientError } = await supabase
        .from('clients')
        .select('id')
        .eq('id', sale.clientId)
        .eq('user_id', user.id)
        .single();
      
      if (clientError || !clientData) {
        return handleSupabaseError(new Error('Client non trouv√© ou n\'appartient pas √† l\'utilisateur connect√©'));
      }
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const saleData = {
      client_id: sale.clientId,
      items: JSON.stringify(sale.items || []),
      subtotal: sale.subtotal,
      tax: sale.tax,
      total: sale.total,
      payment_method: sale.paymentMethod,
      status: sale.status,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('sales')
      .insert([saleData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Sale>) {
    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const updateData: any = { updated_at: new Date().toISOString() };
    
    if (updates.clientId !== undefined) updateData.client_id = updates.clientId;
    if (updates.items !== undefined) updateData.items = updates.items;
    if (updates.subtotal !== undefined) updateData.subtotal = updates.subtotal;
    if (updates.tax !== undefined) updateData.tax = updates.tax;
    if (updates.total !== undefined) updateData.total = updates.total;
    if (updates.paymentMethod !== undefined) updateData.payment_method = updates.paymentMethod;
    if (updates.status !== undefined) updateData.status = updates.status;

    const { data, error } = await supabase
      .from('sales')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    const { error } = await supabase
      .from('sales')
      .delete()
      .eq('id', id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les services
export const serviceService = {
  async getAll() {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('services')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async getById(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('services')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async create(service: Omit<Service, 'id' | 'createdAt' | 'updatedAt'>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const serviceData = {
      name: service.name,
      description: service.description,
      duration: service.duration,
      price: service.price,
      category: service.category,
      applicable_devices: service.applicableDevices,
      is_active: service.isActive,
      user_id: user.id,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('services')
      .insert([serviceData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Service>) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { data, error } = await supabase
      .from('services')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    // Obtenir l'utilisateur connect√©
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return handleSupabaseError(new Error('Utilisateur non connect√©'));
    }

    const { error } = await supabase
      .from('services')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les rendez-vous
export const appointmentService = {
  async getAll() {
    // R√©cup√©rer l'utilisateur connect√© avec son r√¥le
    const currentUser = await getCurrentUser();
    
    if (!currentUser) {
      console.log('‚ö†Ô∏è Aucun utilisateur connect√©, retourner une liste vide');
      return handleSupabaseSuccess([]);
    }
    
    // Si l'utilisateur est admin, r√©cup√©rer tous les rendez-vous
    if (currentUser.role === 'admin') {
      console.log('üîß Utilisateur admin, r√©cup√©ration de tous les rendez-vous');
      const { data, error } = await supabase
        .from('appointments')
        .select('*')
        .order('start_date', { ascending: true });
      
      if (error) return handleSupabaseError(error);
      
      const convertedData = data?.map(appointment => ({
        id: appointment.id,
        userId: appointment.user_id,
        clientId: appointment.client_id,
        repairId: appointment.repair_id,
        title: appointment.title,
        description: appointment.description,
        startDate: new Date(appointment.start_date),
        endDate: new Date(appointment.end_date),
        assignedUserId: appointment.assigned_user_id,
        status: appointment.status,
        createdAt: new Date(appointment.created_at),
        updatedAt: new Date(appointment.updated_at)
      })) || [];
      
      return handleSupabaseSuccess(convertedData);
    }
    
    // Sinon, r√©cup√©rer les rendez-vous de l'utilisateur connect√© ET les rendez-vous syst√®me
    console.log('üîí Utilisateur normal, r√©cup√©ration de ses rendez-vous et rendez-vous syst√®me');
    const { data, error } = await supabase
      .from('appointments')
      .select('*')
      .or(`user_id.eq.${currentUser.id},user_id.eq.00000000-0000-0000-0000-000000000000`)
      .order('start_date', { ascending: true });
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = data?.map(appointment => ({
      id: appointment.id,
      userId: appointment.user_id,
      clientId: appointment.client_id,
      repairId: appointment.repair_id,
      title: appointment.title,
      description: appointment.description,
      startDate: new Date(appointment.start_date),
      endDate: new Date(appointment.end_date),
      assignedUserId: appointment.assigned_user_id,
      status: appointment.status,
      createdAt: new Date(appointment.created_at),
      updatedAt: new Date(appointment.updated_at)
    })) || [];
    
    return handleSupabaseSuccess(convertedData);
  },

  async getById(id: string) {
    const { data, error } = await supabase
      .from('appointments')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) return handleSupabaseError(error);
    
    // Convertir les donn√©es de snake_case vers camelCase
    const convertedData = {
      id: data.id,
      userId: data.user_id,
      clientId: data.client_id,
      repairId: data.repair_id,
      title: data.title,
      description: data.description,
      startDate: new Date(data.start_date),
      endDate: new Date(data.end_date),
      assignedUserId: data.assigned_user_id,
      status: data.status,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at)
    };
    
    return handleSupabaseSuccess(convertedData);
  },

  async create(appointment: Omit<Appointment, 'id' | 'createdAt' | 'updatedAt'>) {
    // R√©cup√©rer l'utilisateur connect√©
    const currentUser = await getCurrentUser();
    const userId = currentUser?.id || '00000000-0000-0000-0000-000000000000';
    
    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    // G√©rer les valeurs vides en les convertissant en null
    const appointmentData = {
      user_id: userId, // Ajouter l'utilisateur connect√©
      client_id: appointment.clientId && appointment.clientId.trim() !== '' ? appointment.clientId : null,
      repair_id: appointment.repairId && appointment.repairId.trim() !== '' ? appointment.repairId : null,
      title: appointment.title,
      description: appointment.description,
      start_date: appointment.startDate.toISOString(),
      end_date: appointment.endDate.toISOString(),
      assigned_user_id: appointment.assignedUserId && appointment.assignedUserId.trim() !== '' ? appointment.assignedUserId : null,
      status: appointment.status,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('appointments')
      .insert([appointmentData])
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async update(id: string, updates: Partial<Appointment>) {
    // Convertir les noms de propri√©t√©s camelCase vers snake_case
    const updateData: any = {
      updated_at: new Date().toISOString()
    };
    
    if (updates.clientId !== undefined) {
      updateData.client_id = updates.clientId && updates.clientId.trim() !== '' ? updates.clientId : null;
    }
    if (updates.repairId !== undefined) {
      updateData.repair_id = updates.repairId && updates.repairId.trim() !== '' ? updates.repairId : null;
    }
    if (updates.title !== undefined) updateData.title = updates.title;
    if (updates.description !== undefined) updateData.description = updates.description;
    if (updates.startDate !== undefined) updateData.start_date = updates.startDate.toISOString();
    if (updates.endDate !== undefined) updateData.end_date = updates.endDate.toISOString();
    if (updates.assignedUserId !== undefined) {
      updateData.assigned_user_id = updates.assignedUserId && updates.assignedUserId.trim() !== '' ? updates.assignedUserId : null;
    }
    if (updates.status !== undefined) updateData.status = updates.status;

    const { data, error } = await supabase
      .from('appointments')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(data);
  },

  async delete(id: string) {
    const { error } = await supabase
      .from('appointments')
      .delete()
      .eq('id', id);
    
    if (error) return handleSupabaseError(error);
    return handleSupabaseSuccess(true);
  }
};

// Service pour les statistiques du tableau de bord
export const dashboardService = {
  async getStats(): Promise<{ success: boolean; data?: DashboardStats; error?: string }> {
    try {
      // R√©cup√©rer les statistiques des r√©parations
      const { data: repairs, error: repairsError } = await supabase
        .from('repairs')
        .select('status, created_at');

      if (repairsError) return handleSupabaseError(repairsError);

      // R√©cup√©rer les statistiques des ventes
      const { data: sales, error: salesError } = await supabase
        .from('sales')
        .select('amount, created_at');

      if (salesError) return handleSupabaseError(salesError);

      // R√©cup√©rer les pi√®ces en rupture de stock
      const { data: lowStockParts, error: lowStockError } = await supabase
        .from('parts')
        .select('*')
        .lte('quantity', 5);

      if (lowStockError) return handleSupabaseError(lowStockError);

      // Calculer les statistiques
      const totalRepairs = repairs?.length || 0;
      const completedRepairs = repairs?.filter(r => r.status === 'completed').length || 0;
      const totalSales = sales?.reduce((sum, sale) => sum + (sale.amount || 0), 0) || 0;
      const lowStockCount = lowStockParts?.length || 0;

      const stats: DashboardStats = {
        totalRepairs,
        activeRepairs: totalRepairs - completedRepairs,
        completedRepairs,
        overdueRepairs: 0,
        todayAppointments: 0,
        monthlyRevenue: 0,
        lowStockItems: lowStockCount,
        pendingMessages: 0
      };

      return handleSupabaseSuccess(stats);
    } catch (error) {
      return handleSupabaseError(error);
    }
  }
};

// Service pour les param√®tres utilisateur
export const userSettingsService = {
  async getUserProfile(userId: string) {
    try {
      console.log('üîç getUserProfile appel√© pour userId:', userId);
      const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      console.log('üìä getUserProfile r√©sultat:', { data, error });
      
      if (error) {
        console.log('‚ö†Ô∏è Erreur getUserProfile, cr√©ation automatique...');
        // Cr√©er automatiquement le profil s'il n'existe pas
        const { data: newData, error: createError } = await supabase
          .from('user_profiles')
          .upsert({
            user_id: userId,
            first_name: 'Utilisateur',
            last_name: '',
            email: 'user@example.com',
            phone: '',
          })
          .select()
          .single();
        
        console.log('üìä Cr√©ation automatique profil:', { data: newData, error: createError });
        
        if (createError) {
          return handleSupabaseError(createError);
        }
        
        return handleSupabaseSuccess(newData);
      }
      
      return handleSupabaseSuccess(data);
    } catch (err) {
      console.error('üí• Exception getUserProfile:', err);
      throw err;
    }
  },

  async updateUserProfile(userId: string, profile: any) {
    try {
      const { data, error } = await supabase
        .from('user_profiles')
        .upsert({
          user_id: userId,
          ...profile,
          updated_at: new Date().toISOString(),
        })
        .select()
        .single();
      
      if (error) {
        return handleSupabaseError(error);
      }
      
      return handleSupabaseSuccess(data);
    } catch (err) {
      throw err;
    }
  },

  async getUserPreferences(userId: string) {
    try {
      console.log('üîç getUserPreferences appel√© pour userId:', userId);
      const { data, error } = await supabase
        .from('user_preferences')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      console.log('üìä getUserPreferences r√©sultat:', { data, error });
      
      if (error) {
        console.log('‚ö†Ô∏è Erreur getUserPreferences, cr√©ation automatique...');
        // Cr√©er automatiquement les pr√©f√©rences s'il n'existent pas
        const { data: newData, error: createError } = await supabase
          .from('user_preferences')
          .upsert({
            user_id: userId,
            notifications_email: true,
            notifications_push: true,
            notifications_sms: false,
            theme_dark_mode: false,
            theme_compact_mode: false,
            language: 'fr',
            two_factor_auth: false,
            multiple_sessions: true,
            repair_notifications: true,
            status_notifications: true,
            stock_notifications: true,
            daily_reports: false,
          })
          .select()
          .single();
        
        console.log('üìä Cr√©ation automatique pr√©f√©rences:', { data: newData, error: createError });
        
        if (createError) {
          return handleSupabaseError(createError);
        }
        
        return handleSupabaseSuccess(newData);
      }
      
      return handleSupabaseSuccess(data);
    } catch (err) {
      console.error('üí• Exception getUserPreferences:', err);
      throw err;
    }
  },

  async updateUserPreferences(userId: string, preferences: any) {
    try {
      const { data, error } = await supabase
        .from('user_preferences')
        .upsert({
          user_id: userId,
          ...preferences,
          updated_at: new Date().toISOString(),
        })
        .select()
        .single();
      
      if (error) {
        return handleSupabaseError(error);
      }
      
      return handleSupabaseSuccess(data);
    } catch (err) {
      throw err;
    }
  },

  async changePassword(userId: string, oldPassword: string, newPassword: string) {
    try {
      const { data, error } = await supabase.auth.updateUser({
        password: newPassword
      });
      
      if (error) {
        return handleSupabaseError(error);
      }
      
      return handleSupabaseSuccess(data);
    } catch (err) {
      throw err;
    }
  },
};

// Service pour les mod√®les d'appareils
export const deviceModelService = {
  async getAll() {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        console.log('‚ö†Ô∏è Aucun utilisateur connect√©, retourner une liste vide');
        return handleSupabaseSuccess([]);
      }
      
      console.log('üîí R√©cup√©ration des mod√®les d\'appareils pour l\'utilisateur:', user.id);
      
      const { data, error } = await supabase
        .from('device_models')
        .select('*')
        .order('brand', { ascending: true })
        .order('model', { ascending: true });
      
      if (error) return handleSupabaseError(error);
      
      // Convertir les donn√©es de snake_case vers camelCase
      const convertedData = data?.map(model => ({
        id: model.id,
        brand: model.brand,
        model: model.model,
        type: model.type,
        year: model.year,
        specifications: model.specifications || {},
        commonIssues: model.common_issues || [],
        repairDifficulty: model.repair_difficulty,
        partsAvailability: model.parts_availability,
        isActive: model.is_active,
        createdAt: new Date(model.created_at),
        updatedAt: new Date(model.updated_at)
      })) || [];
      
      console.log('‚úÖ Mod√®les r√©cup√©r√©s:', convertedData.length);
      return handleSupabaseSuccess(convertedData);
    } catch (err) {
      console.error('üí• Exception dans deviceModelService.getAll:', err);
      return handleSupabaseSuccess([]);
    }
  },

  async getById(id: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { data, error } = await supabase
        .from('device_models')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) return handleSupabaseError(error);
      
      // Convertir les donn√©es
      const convertedData = {
        id: data.id,
        brand: data.brand,
        model: data.model,
        type: data.type,
        year: data.year,
        specifications: data.specifications || {},
        commonIssues: data.common_issues || [],
        repairDifficulty: data.repair_difficulty,
        partsAvailability: data.parts_availability,
        isActive: data.is_active,
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at)
      };
      
      return handleSupabaseSuccess(convertedData);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async create(model: any) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      // Convertir les noms de propri√©t√©s camelCase vers snake_case
      // Le trigger s'occupe automatiquement de workshop_id, created_by, et timestamps
      const modelData = {
        brand: model.brand,
        model: model.model,
        type: model.type,
        year: model.year,
        specifications: model.specifications || {},
        common_issues: model.commonIssues || [],
        repair_difficulty: model.repairDifficulty,
        parts_availability: model.partsAvailability,
        is_active: model.isActive !== undefined ? model.isActive : true
      };

      const { data, error } = await supabase
        .from('device_models')
        .insert([modelData])
        .select()
        .single();
      
      if (error) return handleSupabaseError(error);
      
      // Convertir la r√©ponse
      const convertedData = {
        id: data.id,
        brand: data.brand,
        model: data.model,
        type: data.type,
        year: data.year,
        specifications: data.specifications || {},
        commonIssues: data.common_issues || [],
        repairDifficulty: data.repair_difficulty,
        partsAvailability: data.parts_availability,
        isActive: data.is_active,
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at)
      };
      
      return handleSupabaseSuccess(convertedData);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async update(id: string, updates: any) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      // Convertir les mises √† jour
      const updateData: any = {
        updated_at: new Date().toISOString()
      };

      if (updates.brand !== undefined) updateData.brand = updates.brand;
      if (updates.model !== undefined) updateData.model = updates.model;
      if (updates.type !== undefined) updateData.type = updates.type;
      if (updates.year !== undefined) updateData.year = updates.year;
      if (updates.specifications !== undefined) updateData.specifications = updates.specifications;
      if (updates.commonIssues !== undefined) updateData.common_issues = updates.commonIssues;
      if (updates.repairDifficulty !== undefined) updateData.repair_difficulty = updates.repairDifficulty;
      if (updates.partsAvailability !== undefined) updateData.parts_availability = updates.partsAvailability;
      if (updates.isActive !== undefined) updateData.is_active = updates.isActive;

      const { data, error } = await supabase
        .from('device_models')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();
      
      if (error) return handleSupabaseError(error);
      
      // Convertir la r√©ponse
      const convertedData = {
        id: data.id,
        brand: data.brand,
        model: data.model,
        type: data.type,
        year: data.year,
        specifications: data.specifications || {},
        commonIssues: data.common_issues || [],
        repairDifficulty: data.repair_difficulty,
        partsAvailability: data.parts_availability,
        isActive: data.is_active,
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at)
      };
      
      return handleSupabaseSuccess(convertedData);
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },

  async delete(id: string) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return handleSupabaseError(new Error('Utilisateur non connect√©'));
      }

      const { error } = await supabase
        .from('device_models')
        .delete()
        .eq('id', id);
      
      if (error) return handleSupabaseError(error);
      return handleSupabaseSuccess({ success: true });
    } catch (err) {
      return handleSupabaseError(err as any);
    }
  },
};

export default {
  userService,
  systemSettingsService,
  userSettingsService,
  deviceModelService,
};
